{
  "version": 3,
  "sources": ["../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts", "../../.pnpm/@ai-sdk+provider@0.0.17/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/convert-async-generator-to-readable-stream.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/generate-id.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/load-setting.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/parse-json.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/validate-types.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/validator.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/response-handler.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts", "../../.pnpm/@ai-sdk+provider-utils@1.0.9_zod@3.24.1/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/anthropic-facade.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/anthropic-messages-language-model.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/anthropic-error.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/convert-to-anthropic-messages-prompt.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/map-anthropic-stop-reason.ts", "../../.pnpm/@ai-sdk+anthropic@0.0.39_zod@3.24.1/node_modules/@ai-sdk/anthropic/src/anthropic-provider.ts"],
  "sourcesContent": ["/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error: unknown): error is APICallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as APICallError).url === 'string' &&\n      typeof (error as APICallError).requestBodyValues === 'object' &&\n      ((error as APICallError).statusCode == null ||\n        typeof (error as APICallError).statusCode === 'number') &&\n      ((error as APICallError).responseHeaders == null ||\n        typeof (error as APICallError).responseHeaders === 'object') &&\n      ((error as APICallError).responseBody == null ||\n        typeof (error as APICallError).responseBody === 'string') &&\n      ((error as APICallError).cause == null ||\n        typeof (error as APICallError).cause === 'object') &&\n      typeof (error as APICallError).isRetryable === 'boolean' &&\n      ((error as APICallError).data == null ||\n        typeof (error as APICallError).data === 'object')\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(\n    error: unknown,\n  ): error is EmptyResponseBodyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({ prompt, message }: { prompt: unknown; message: string }) {\n    super({\n      name,\n      message: `Invalid prompt: ${message}`,\n    });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error: unknown): error is InvalidPromptError {\n    return error instanceof Error && error.name === name && prompt != null;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      prompt: this.prompt,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(\n    error: unknown,\n  ): error is InvalidResponseDataError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      (error as InvalidResponseDataError).data != null\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      data: this.data,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error: unknown): error is JSONParseError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as JSONParseError).text === 'string' &&\n      typeof (error as JSONParseError).cause === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      valueText: this.text,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error: unknown): error is LoadAPIKeyError {\n    return error instanceof Error && error.name === name;\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error: unknown): error is LoadSettingError {\n    return error instanceof Error && error.name === name;\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(\n    error: unknown,\n  ): error is NoContentGeneratedError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      'provider' in error &&\n      typeof error.provider === 'string' &&\n      'modelId' in error &&\n      typeof error.modelId === 'string' &&\n      'maxEmbeddingsPerCall' in error &&\n      typeof error.maxEmbeddingsPerCall === 'number' &&\n      'values' in error &&\n      Array.isArray(error.values)\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error: unknown): error is TypeValidationError {\n    return error instanceof Error && error.name === name;\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n\n      value: this.value,\n    };\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({ functionality }: { functionality: string }) {\n    super({\n      name,\n      message: `'${functionality}' functionality not supported.`,\n    });\n\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(\n    error: unknown,\n  ): error is UnsupportedFunctionalityError {\n    return (\n      error instanceof Error &&\n      error.name === name &&\n      typeof (error as UnsupportedFunctionalityError).functionality === 'string'\n    );\n  }\n\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n\n      functionality: this.functionality,\n    };\n  }\n}\n", "export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n", "/**\n * Converts an AsyncGenerator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncGenerator.\n * @param {AsyncGenerator<T>} stream - The AsyncGenerator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncGenerator.\n */\nexport function convertAsyncGeneratorToReadableStream<T>(\n  stream: AsyncGenerator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n", "/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n", "import { customAlphabet } from 'nanoid/non-secure';\n\n/**\n * Generates a 7-character random string to use for IDs. Not secure.\n */\nexport const generateId = customAlphabet(\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  7,\n);\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n", "import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n", "import { LoadSettingError } from '@ai-sdk/provider';\n\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n", "import { JSONParseError, TypeValidationError } from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {unknown} - The parsed JSON object.\n */\nexport function parseJSON({ text }: { text: string }): unknown;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isJSONParseError(error) ||\n      TypeValidationError.isTypeValidationError(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON({ text }: { text: string }): ParseResult<unknown>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError } {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return {\n        success: true,\n        value: value as T,\n      };\n    }\n\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isJSONParseError(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n@deprecated Use `isParsableJson` instead.\n */\nexport const isParseableJson = isParsableJson;\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, isValidator, zodValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw new TypeValidationError({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const schema = isValidator(inputSchema)\n    ? inputSchema\n    : zodValidator(inputSchema);\n\n  try {\n    if (schema.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const validationResult = schema.validate(value);\n\n    if (validationResult.success) {\n      return validationResult;\n    }\n\n    return {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: validationResult.error,\n      }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.isTypeValidationError(error)\n        ? error\n        : new TypeValidationError({ value, cause: error }),\n    };\n  }\n}\n", "import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (\n    value: unknown,\n  ) => { success: true; value: OBJECT } | { success: false; error: Error };\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate: (\n    value: unknown,\n  ) => { success: true; value: OBJECT } | { success: false; error: Error },\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: ReturnType<typeof getOriginalFetch>;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: ReturnType<typeof getOriginalFetch>;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "export function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n", "import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  EventSourceParserStream,\n  ParsedEvent,\n} from 'eventsource-parser/stream';\nimport { ZodSchema } from 'zod';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { ParseResult, parseJSON, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<ParsedEvent, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n    };\n  };\n", "export function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = globalThis.atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return globalThis.btoa(latin1string);\n}\n", "export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n", "import { loadApiKey, withoutTrailingSlash } from '@ai-sdk/provider-utils';\nimport { AnthropicMessagesLanguageModel } from './anthropic-messages-language-model';\nimport {\n  AnthropicMessagesModelId,\n  AnthropicMessagesSettings,\n} from './anthropic-messages-settings';\nimport { AnthropicProviderSettings } from './anthropic-provider';\n\n/**\n * @deprecated Use `createAnthropic` instead.\n */\nexport class Anthropic {\n  /**\n   * Base URL for Anthropic API calls.\n   */\n  readonly baseURL: string;\n\n  readonly apiKey?: string;\n\n  readonly headers?: Record<string, string>;\n\n  /**\n   * Creates a new Anthropic provider instance.\n   */\n  constructor(options: AnthropicProviderSettings = {}) {\n    this.baseURL =\n      withoutTrailingSlash(options.baseURL ?? options.baseUrl) ??\n      'https://api.anthropic.com/v1';\n    this.apiKey = options.apiKey;\n    this.headers = options.headers;\n  }\n\n  private get baseConfig() {\n    return {\n      baseURL: this.baseURL,\n      headers: () => ({\n        'anthropic-version': '2023-06-01',\n        'anthropic-beta': 'tools-2024-04-04',\n        'x-api-key': loadApiKey({\n          apiKey: this.apiKey,\n          environmentVariableName: 'ANTHROPIC_API_KEY',\n          description: 'Anthropic',\n        }),\n        ...this.headers,\n      }),\n    };\n  }\n\n  /**\n   * @deprecated Use `chat()` instead.\n   */\n  messages(\n    modelId: AnthropicMessagesModelId,\n    settings: AnthropicMessagesSettings = {},\n  ) {\n    return this.chat(modelId, settings);\n  }\n\n  chat(\n    modelId: AnthropicMessagesModelId,\n    settings: AnthropicMessagesSettings = {},\n  ) {\n    return new AnthropicMessagesLanguageModel(modelId, settings, {\n      provider: 'anthropic.messages',\n      ...this.baseConfig,\n    });\n  }\n}\n", "import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1FunctionToolCall,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { anthropicFailedResponseHandler } from './anthropic-error';\nimport {\n  AnthropicMessagesModelId,\n  AnthropicMessagesSettings,\n} from './anthropic-messages-settings';\nimport { convertToAnthropicMessagesPrompt } from './convert-to-anthropic-messages-prompt';\nimport { mapAnthropicStopReason } from './map-anthropic-stop-reason';\n\ntype AnthropicMessagesConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: typeof fetch;\n};\n\nexport class AnthropicMessagesLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'tool';\n  readonly supportsImageUrls = false;\n\n  readonly modelId: AnthropicMessagesModelId;\n  readonly settings: AnthropicMessagesSettings;\n\n  private readonly config: AnthropicMessagesConfig;\n\n  constructor(\n    modelId: AnthropicMessagesModelId,\n    settings: AnthropicMessagesSettings,\n    config: AnthropicMessagesConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private async getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const messagesPrompt = convertToAnthropicMessagesPrompt(prompt);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      top_k: topK ?? this.settings.topK,\n\n      // standardized settings:\n      max_tokens: maxTokens ?? 4096, // 4096: max model output tokens\n      temperature,\n      top_p: topP,\n      stop_sequences: stopSequences,\n\n      // prompt:\n      system: messagesPrompt.system,\n      messages: messagesPrompt.messages,\n    };\n\n    switch (type) {\n      case 'regular': {\n        return {\n          args: { ...baseArgs, ...prepareToolsAndToolChoice(mode) },\n          warnings,\n        };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'json-mode object generation',\n        });\n      }\n\n      case 'object-tool': {\n        const { name, description, parameters } = mode.tool;\n\n        return {\n          args: {\n            ...baseArgs,\n            tools: [{ name, description, input_schema: parameters }],\n            tool_choice: { type: 'tool', name },\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = await this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/messages`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: anthropicFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        anthropicMessagesResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    // extract text\n    let text = '';\n    for (const content of response.content) {\n      if (content.type === 'text') {\n        text += content.text;\n      }\n    }\n\n    // extract tool calls\n    let toolCalls: LanguageModelV1FunctionToolCall[] | undefined = undefined;\n    if (response.content.some(content => content.type === 'tool_use')) {\n      toolCalls = [];\n      for (const content of response.content) {\n        if (content.type === 'tool_use') {\n          toolCalls.push({\n            toolCallType: 'function',\n            toolCallId: content.id,\n            toolName: content.name,\n            args: JSON.stringify(content.input),\n          });\n        }\n      }\n    }\n\n    return {\n      text,\n      toolCalls,\n      finishReason: mapAnthropicStopReason(response.stop_reason),\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = await this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/messages`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...args,\n        stream: true,\n      },\n      failedResponseHandler: anthropicFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        anthropicMessagesChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'other';\n    const usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n\n    const toolCallContentBlocks: Record<\n      number,\n      {\n        toolCallId: string;\n        toolName: string;\n        jsonText: string;\n      }\n    > = {};\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof anthropicMessagesChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            if (!chunk.success) {\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            switch (value.type) {\n              case 'ping': {\n                return; // ignored\n              }\n\n              case 'content_block_start': {\n                const contentBlockType = value.content_block.type;\n\n                switch (contentBlockType) {\n                  case 'text': {\n                    return; // ignored\n                  }\n\n                  case 'tool_use': {\n                    toolCallContentBlocks[value.index] = {\n                      toolCallId: value.content_block.id,\n                      toolName: value.content_block.name,\n                      jsonText: '',\n                    };\n                    return;\n                  }\n\n                  default: {\n                    const _exhaustiveCheck: never = contentBlockType;\n                    throw new Error(\n                      `Unsupported content block type: ${_exhaustiveCheck}`,\n                    );\n                  }\n                }\n              }\n\n              case 'content_block_stop': {\n                // when finishing a tool call block, send the full tool call:\n                if (toolCallContentBlocks[value.index] != null) {\n                  const contentBlock = toolCallContentBlocks[value.index];\n\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: contentBlock.toolCallId,\n                    toolName: contentBlock.toolName,\n                    args: contentBlock.jsonText,\n                  });\n\n                  delete toolCallContentBlocks[value.index];\n                }\n\n                return;\n              }\n\n              case 'content_block_delta': {\n                const deltaType = value.delta.type;\n                switch (deltaType) {\n                  case 'text_delta': {\n                    controller.enqueue({\n                      type: 'text-delta',\n                      textDelta: value.delta.text,\n                    });\n\n                    return;\n                  }\n\n                  case 'input_json_delta': {\n                    const contentBlock = toolCallContentBlocks[value.index];\n\n                    controller.enqueue({\n                      type: 'tool-call-delta',\n                      toolCallType: 'function',\n                      toolCallId: contentBlock.toolCallId,\n                      toolName: contentBlock.toolName,\n                      argsTextDelta: value.delta.partial_json,\n                    });\n\n                    contentBlock.jsonText += value.delta.partial_json;\n\n                    return;\n                  }\n\n                  default: {\n                    const _exhaustiveCheck: never = deltaType;\n                    throw new Error(\n                      `Unsupported delta type: ${_exhaustiveCheck}`,\n                    );\n                  }\n                }\n              }\n\n              case 'message_start': {\n                usage.promptTokens = value.message.usage.input_tokens;\n                usage.completionTokens = value.message.usage.output_tokens;\n                return;\n              }\n\n              case 'message_delta': {\n                usage.completionTokens = value.usage.output_tokens;\n                finishReason = mapAnthropicStopReason(value.delta.stop_reason);\n                return;\n              }\n\n              case 'message_stop': {\n                controller.enqueue({ type: 'finish', finishReason, usage });\n                return;\n              }\n\n              case 'error': {\n                controller.enqueue({ type: 'error', error: value.error });\n                return;\n              }\n\n              default: {\n                const _exhaustiveCheck: never = value;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst anthropicMessagesResponseSchema = z.object({\n  type: z.literal('message'),\n  content: z.array(\n    z.discriminatedUnion('type', [\n      z.object({\n        type: z.literal('text'),\n        text: z.string(),\n      }),\n      z.object({\n        type: z.literal('tool_use'),\n        id: z.string(),\n        name: z.string(),\n        input: z.unknown(),\n      }),\n    ]),\n  ),\n  stop_reason: z.string().optional().nullable(),\n  usage: z.object({\n    input_tokens: z.number(),\n    output_tokens: z.number(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst anthropicMessagesChunkSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('message_start'),\n    message: z.object({\n      usage: z.object({\n        input_tokens: z.number(),\n        output_tokens: z.number(),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('content_block_start'),\n    index: z.number(),\n    content_block: z.discriminatedUnion('type', [\n      z.object({\n        type: z.literal('text'),\n        text: z.string(),\n      }),\n      z.object({\n        type: z.literal('tool_use'),\n        id: z.string(),\n        name: z.string(),\n      }),\n    ]),\n  }),\n  z.object({\n    type: z.literal('content_block_delta'),\n    index: z.number(),\n    delta: z.discriminatedUnion('type', [\n      z.object({\n        type: z.literal('input_json_delta'),\n        partial_json: z.string(),\n      }),\n      z.object({\n        type: z.literal('text_delta'),\n        text: z.string(),\n      }),\n    ]),\n  }),\n  z.object({\n    type: z.literal('content_block_stop'),\n    index: z.number(),\n  }),\n  z.object({\n    type: z.literal('error'),\n    error: z.object({\n      type: z.string(),\n      message: z.string(),\n    }),\n  }),\n  z.object({\n    type: z.literal('message_delta'),\n    delta: z.object({ stop_reason: z.string().optional().nullable() }),\n    usage: z.object({ output_tokens: z.number() }),\n  }),\n  z.object({\n    type: z.literal('message_stop'),\n  }),\n  z.object({\n    type: z.literal('ping'),\n  }),\n]);\n\nfunction prepareToolsAndToolChoice(\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  },\n) {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined };\n  }\n\n  const mappedTools = tools.map(tool => ({\n    name: tool.name,\n    description: tool.description,\n    input_schema: tool.parameters,\n  }));\n\n  const toolChoice = mode.toolChoice;\n\n  if (toolChoice == null) {\n    return { tools: mappedTools, tool_choice: undefined };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return { tools: mappedTools, tool_choice: { type: 'auto' } };\n    case 'required':\n      return { tools: mappedTools, tool_choice: { type: 'any' } };\n    case 'none':\n      // Anthropic does not support 'none' tool choice, so we remove the tools:\n      return { tools: undefined, tool_choice: undefined };\n    case 'tool':\n      return {\n        tools: mappedTools,\n        tool_choice: { type: 'tool', name: toolChoice.toolName },\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new Error(`Unsupported tool choice type: ${_exhaustiveCheck}`);\n    }\n  }\n}\n", "import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\nconst anthropicErrorDataSchema = z.object({\n  type: z.literal('error'),\n  error: z.object({\n    type: z.string(),\n    message: z.string(),\n  }),\n});\n\nexport type AnthropicErrorData = z.infer<typeof anthropicErrorDataSchema>;\n\nexport const anthropicFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: anthropicErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n", "import {\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport {\n  AnthropicAssistantMessage,\n  AnthropicMessage,\n  AnthropicMessagesPrompt,\n  AnthropicUserMessage,\n} from './anthropic-messages-prompt';\n\nexport function convertToAnthropicMessagesPrompt(\n  prompt: LanguageModelV1Prompt,\n): AnthropicMessagesPrompt {\n  const blocks = groupIntoBlocks(prompt);\n\n  let system: string | undefined = undefined;\n  const messages: AnthropicMessage[] = [];\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    const type = block.type;\n\n    switch (type) {\n      case 'system': {\n        if (system != null) {\n          throw new UnsupportedFunctionalityError({\n            functionality:\n              'Multiple system messages that are separated by user/assistant messages',\n          });\n        }\n\n        system = block.messages.map(({ content }) => content).join('\\n');\n        break;\n      }\n\n      case 'user': {\n        // combines all user and tool messages in this block into a single message:\n        const anthropicContent: AnthropicUserMessage['content'] = [];\n\n        for (const { role, content } of block.messages) {\n          switch (role) {\n            case 'user': {\n              for (const part of content) {\n                switch (part.type) {\n                  case 'text': {\n                    anthropicContent.push({ type: 'text', text: part.text });\n                    break;\n                  }\n                  case 'image': {\n                    if (part.image instanceof URL) {\n                      // The AI SDK automatically downloads images for user image parts with URLs\n                      throw new UnsupportedFunctionalityError({\n                        functionality: 'Image URLs in user messages',\n                      });\n                    }\n\n                    anthropicContent.push({\n                      type: 'image',\n                      source: {\n                        type: 'base64',\n                        media_type: part.mimeType ?? 'image/jpeg',\n                        data: convertUint8ArrayToBase64(part.image),\n                      },\n                    });\n\n                    break;\n                  }\n                }\n              }\n\n              break;\n            }\n            case 'tool': {\n              for (const part of content) {\n                anthropicContent.push({\n                  type: 'tool_result',\n                  tool_use_id: part.toolCallId,\n                  content: JSON.stringify(part.result),\n                  is_error: part.isError,\n                });\n              }\n\n              break;\n            }\n            default: {\n              const _exhaustiveCheck: never = role;\n              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n\n        messages.push({ role: 'user', content: anthropicContent });\n\n        break;\n      }\n\n      case 'assistant': {\n        // combines multiple assistant messages in this block into a single message:\n        const anthropicContent: AnthropicAssistantMessage['content'] = [];\n\n        for (const { content } of block.messages) {\n          for (let j = 0; j < content.length; j++) {\n            const part = content[j];\n            switch (part.type) {\n              case 'text': {\n                anthropicContent.push({\n                  type: 'text',\n                  text:\n                    // trim the last text part if it's the last message in the block\n                    // because Anthropic does not allow trailing whitespace\n                    // in pre-filled assistant responses\n                    i === blocks.length - 1 && j === block.messages.length - 1\n                      ? part.text.trim()\n                      : part.text,\n                });\n                break;\n              }\n\n              case 'tool-call': {\n                anthropicContent.push({\n                  type: 'tool_use',\n                  id: part.toolCallId,\n                  name: part.toolName,\n                  input: part.args,\n                });\n                break;\n              }\n            }\n          }\n        }\n\n        messages.push({ role: 'assistant', content: anthropicContent });\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return {\n    system,\n    messages,\n  };\n}\n\ntype SystemBlock = {\n  type: 'system';\n  messages: Array<LanguageModelV1Message & { role: 'system' }>;\n};\ntype AssistantBlock = {\n  type: 'assistant';\n  messages: Array<LanguageModelV1Message & { role: 'assistant' }>;\n};\ntype UserBlock = {\n  type: 'user';\n  messages: Array<LanguageModelV1Message & { role: 'user' | 'tool' }>;\n};\n\nfunction groupIntoBlocks(\n  prompt: LanguageModelV1Prompt,\n): Array<SystemBlock | AssistantBlock | UserBlock> {\n  const blocks: Array<SystemBlock | AssistantBlock | UserBlock> = [];\n  let currentBlock: SystemBlock | AssistantBlock | UserBlock | undefined =\n    undefined;\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        if (currentBlock?.type !== 'system') {\n          currentBlock = { type: 'system', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push({ role, content });\n        break;\n      }\n      case 'assistant': {\n        if (currentBlock?.type !== 'assistant') {\n          currentBlock = { type: 'assistant', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push({ role, content });\n        break;\n      }\n      case 'user': {\n        if (currentBlock?.type !== 'user') {\n          currentBlock = { type: 'user', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push({ role, content });\n        break;\n      }\n      case 'tool': {\n        if (currentBlock?.type !== 'user') {\n          currentBlock = { type: 'user', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push({ role, content });\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return blocks;\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapAnthropicStopReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'end_turn':\n    case 'stop_sequence':\n      return 'stop';\n    case 'tool_use':\n      return 'tool-calls';\n    case 'max_tokens':\n      return 'length';\n    default:\n      return 'other';\n  }\n}\n", "import { loadApiKey, withoutTrailingSlash } from '@ai-sdk/provider-utils';\nimport { AnthropicMessagesLanguageModel } from './anthropic-messages-language-model';\nimport {\n  AnthropicMessagesModelId,\n  AnthropicMessagesSettings,\n} from './anthropic-messages-settings';\n\nexport interface AnthropicProvider {\n  /**\nCreates a model for text generation.\n*/\n  (\n    modelId: AnthropicMessagesModelId,\n    settings?: AnthropicMessagesSettings,\n  ): AnthropicMessagesLanguageModel;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(\n    modelId: AnthropicMessagesModelId,\n    settings?: AnthropicMessagesSettings,\n  ): AnthropicMessagesLanguageModel;\n\n  /**\nCreates a model for text generation.\n*/\n  chat(\n    modelId: AnthropicMessagesModelId,\n    settings?: AnthropicMessagesSettings,\n  ): AnthropicMessagesLanguageModel;\n\n  /**\n   * @deprecated Use `chat()` instead.\n   */\n  messages(\n    modelId: AnthropicMessagesModelId,\n    settings?: AnthropicMessagesSettings,\n  ): AnthropicMessagesLanguageModel;\n}\n\nexport interface AnthropicProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://api.anthropic.com/v1`.\n   */\n  baseURL?: string;\n\n  /**\n@deprecated Use `baseURL` instead.\n   */\n  baseUrl?: string;\n\n  /**\nAPI key that is being send using the `x-api-key` header.\nIt defaults to the `ANTHROPIC_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: typeof fetch;\n\n  generateId?: () => string;\n}\n\n/**\nCreate an Anthropic provider instance.\n */\nexport function createAnthropic(\n  options: AnthropicProviderSettings = {},\n): AnthropicProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL ?? options.baseUrl) ??\n    'https://api.anthropic.com/v1';\n\n  const getHeaders = () => ({\n    'anthropic-version': '2023-06-01',\n    'x-api-key': loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'ANTHROPIC_API_KEY',\n      description: 'Anthropic',\n    }),\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: AnthropicMessagesModelId,\n    settings: AnthropicMessagesSettings = {},\n  ) =>\n    new AnthropicMessagesLanguageModel(modelId, settings, {\n      provider: 'anthropic.messages',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (\n    modelId: AnthropicMessagesModelId,\n    settings?: AnthropicMessagesSettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Anthropic model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.messages = createChatModel;\n\n  return provider as AnthropicProvider;\n}\n\n/**\nDefault Anthropic provider instance.\n */\nexport const anthropic = createAnthropic();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAM,SAAS;AACf,IAAM,SAAS,OAAO,IAAI,MAAM;AALhC,IAAA;AAWO,IAAM,cAAN,MAAMA,qBAAmB,MAAM;;;;;;;;;EAgBpC,YAAY;IACV,MAAAC;IACA;IACA;EACF,GAIG;AACD,UAAM,OAAO;AAxBf,SAAkB,EAAA,IAAU;AA0B1B,SAAK,OAAOA;AACZ,SAAK,QAAQ;EACf;;;;;;EAOA,OAAO,WAAW,OAAqC;AACrD,WAAOD,aAAW,UAAU,OAAO,MAAM;EAC3C;EAEA,OAAiB,UAAU,OAAgBE,UAAyB;AAClE,UAAM,eAAe,OAAO,IAAIA,QAAM;AACtC,WACE,SAAS,QACT,OAAO,UAAU,YACjB,gBAAgB,SAChB,OAAO,MAAM,YAAY,MAAM,aAC/B,MAAM,YAAY,MAAM;EAE5B;;;;;;;EAQA,SAAS;AACP,WAAO;MACL,MAAM,KAAK;MACX,SAAS,KAAK;IAChB;EACF;AACF;AA9DoB,KAAA;AADb,IAAM,aAAN;ACTP,IAAM,OAAO;AACb,IAAMA,UAAS,mBAAmB,IAAI;AACtC,IAAMC,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAMO,IAAM,eAAN,cAA2B,WAAW;EAa3C,YAAY;IACV;IACA;IACA;IACA;IACA;IACA;IACA;IACA,cAAc,cAAc,SACzB,eAAe;IACd,eAAe;IACf,eAAe;IACf,cAAc;;IAClB;EACF,GAUG;AACD,UAAM,EAAE,MAAM,SAAS,MAAM,CAAC;AArChC,SAAkBA,GAAAA,IAAU;AAuC1B,SAAK,MAAM;AACX,SAAK,oBAAoB;AACzB,SAAK,aAAa;AAClB,SAAK,kBAAkB;AACvB,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,OAAO;EACd;EAEA,OAAO,WAAW,OAAuC;AACvD,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;;;;EAKA,OAAO,eAAe,OAAuC;AAC3D,WACE,iBAAiB,SACjB,MAAM,SAAS,QACf,OAAQ,MAAuB,QAAQ,YACvC,OAAQ,MAAuB,sBAAsB,aACnD,MAAuB,cAAc,QACrC,OAAQ,MAAuB,eAAe,cAC9C,MAAuB,mBAAmB,QAC1C,OAAQ,MAAuB,oBAAoB,cACnD,MAAuB,gBAAgB,QACvC,OAAQ,MAAuB,iBAAiB,cAChD,MAAuB,SAAS,QAChC,OAAQ,MAAuB,UAAU,aAC3C,OAAQ,MAAuB,gBAAgB,cAC7C,MAAuB,QAAQ,QAC/B,OAAQ,MAAuB,SAAS;EAE9C;;;;EAKA,SAAS;AACP,WAAO;MACL,MAAM,KAAK;MACX,SAAS,KAAK;MACd,KAAK,KAAK;MACV,mBAAmB,KAAK;MACxB,YAAY,KAAK;MACjB,iBAAiB,KAAK;MACtB,cAAc,KAAK;MACnB,OAAO,KAAK;MACZ,aAAa,KAAK;MAClB,MAAM,KAAK;IACb;EACF;AACF;AA5FoBE,MAAAD;ACLpB,IAAMF,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAMO,IAAM,yBAAN,cAAqC,WAAW;;EAGrD,YAAY,EAAE,UAAU,sBAAsB,IAA0B,CAAC,GAAG;AAC1E,UAAM,EAAE,MAAAH,OAAM,QAAQ,CAAC;AAHzB,SAAkBG,GAAAA,IAAU;EAI5B;EAEA,OAAO,WAAW,OAAiD;AACjE,WAAO,WAAW,UAAU,OAAOF,OAAM;EAC3C;;;;EAKA,OAAO,yBACL,OACiC;AACjC,WAAO,iBAAiB,SAAS,MAAM,SAASD;EAClD;AACF;AAlBoBG,MAAAD;ACPb,SAAS,gBAAgB,OAA4B;AAC1D,MAAI,SAAS,MAAM;AACjB,WAAO;EACT;AAEA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;EACT;AAEA,MAAI,iBAAiB,OAAO;AAC1B,WAAO,MAAM;EACf;AAEA,SAAO,KAAK,UAAU,KAAK;AAC7B;ACZA,IAAMF,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE;AAWoBC,MAAAC;ACTpB,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAMD,UAAS,OAAO,IAAIE,OAAM;AAJhC,IAAAH;AAWoBI,MAAAC;ACRpB,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAMD,UAAS,OAAO,IAAIE,OAAM;AALhC,IAAAH;AAOO,IAAM,iBAAN,cAA6B,WAAW;EAK7C,YAAY,EAAE,MAAM,MAAM,GAAqC;AAC7D,UAAM;MACJ,MAAAE;MACA,SACE,8BACS,IAAI;iBACK,gBAAgB,KAAK,CAAC;MAC1C;IACF,CAAC;AAZH,SAAkBF,GAAAA,IAAU;AAc1B,SAAK,OAAO;EACd;EAEA,OAAO,WAAW,OAAyC;AACzD,WAAO,WAAW,UAAU,OAAOG,OAAM;EAC3C;;;;EAKA,OAAO,iBAAiB,OAAyC;AAC/D,WACE,iBAAiB,SACjB,MAAM,SAASD,SACf,OAAQ,MAAyB,SAAS,YAC1C,OAAQ,MAAyB,UAAU;EAE/C;;;;EAKA,SAAS;AACP,WAAO;MACL,MAAM,KAAK;MACX,SAAS,KAAK;MACd,OAAO,KAAK;MACZ,OAAO,KAAK;MAEZ,WAAW,KAAK;IAClB;EACF;AACF;AA9CoBF,MAAAC;ACNpB,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAMD,UAAS,OAAO,IAAIE,OAAM;AAJhC,IAAAH;AAMO,IAAM,kBAAN,cAA8B,WAAW;;EAG9C,YAAY,EAAE,QAAQ,GAAwB;AAC5C,UAAM,EAAE,MAAAE,OAAM,QAAQ,CAAC;AAHzB,SAAkBF,GAAAA,IAAU;EAI5B;EAEA,OAAO,WAAW,OAA0C;AAC1D,WAAO,WAAW,UAAU,OAAOG,OAAM;EAC3C;;;;EAKA,OAAO,kBAAkB,OAA0C;AACjE,WAAO,iBAAiB,SAAS,MAAM,SAASD;EAClD;AACF;AAhBoBF,MAAAC;ACLpB,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAMD,UAAS,OAAO,IAAIE,OAAM;AAJhC,IAAAH;AAOoBI,MAAAC;ACLpB,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAMD,UAAS,OAAO,IAAIE,OAAM;AAJhC,IAAAH;AAUoBI,MAAAC;ACRpB,IAAMC,QAAO;AACb,IAAMC,WAAS,mBAAmBD,KAAI;AACtC,IAAMD,WAAS,OAAO,IAAIE,QAAM;AAJhC,IAAAH;AAOoBI,OAAAC;ACJpB,IAAMC,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAMD,WAAS,OAAO,IAAIE,QAAM;AALhC,IAAAH;AAOO,IAAM,sBAAN,cAAkC,WAAW;EAKlD,YAAY,EAAE,OAAO,MAAM,GAAuC;AAChE,UAAM;MACJ,MAAAE;MACA,SACE,kCACU,KAAK,UAAU,KAAK,CAAC;iBACb,gBAAgB,KAAK,CAAC;MAC1C;IACF,CAAC;AAZH,SAAkBF,IAAAA,IAAU;AAc1B,SAAK,QAAQ;EACf;EAEA,OAAO,WAAW,OAA8C;AAC9D,WAAO,WAAW,UAAU,OAAOG,QAAM;EAC3C;;;;EAKA,OAAO,sBAAsB,OAA8C;AACzE,WAAO,iBAAiB,SAAS,MAAM,SAASD;EAClD;;;;EAKA,SAAS;AACP,WAAO;MACL,MAAM,KAAK;MACX,SAAS,KAAK;MACd,OAAO,KAAK;MACZ,OAAO,KAAK;MAEZ,OAAO,KAAK;IACd;EACF;AACF;AAzCoBF,OAAAC;ACNpB,IAAMC,SAAO;AACb,IAAMC,WAAS,mBAAmBD,MAAI;AACtC,IAAMD,WAAS,OAAO,IAAIE,QAAM;AAJhC,IAAAH;AAMO,IAAM,gCAAN,cAA4C,WAAW;EAK5D,YAAY,EAAE,cAAc,GAA8B;AACxD,UAAM;MACJ,MAAAE;MACA,SAAS,IAAI,aAAa;IAC5B,CAAC;AARH,SAAkBF,IAAAA,IAAU;AAU1B,SAAK,gBAAgB;EACvB;EAEA,OAAO,WAAW,OAAwD;AACxE,WAAO,WAAW,UAAU,OAAOG,QAAM;EAC3C;;;;EAKA,OAAO,gCACL,OACwC;AACxC,WACE,iBAAiB,SACjB,MAAM,SAASD,UACf,OAAQ,MAAwC,kBAAkB;EAEtE;;;;EAKA,SAAS;AACP,WAAO;MACL,MAAM,KAAK;MACX,SAAS,KAAK;MACd,OAAO,KAAK;MAEZ,eAAe,KAAK;IACtB;EACF;AACF;AA1CoBF,OAAAC;;;ASNpB,+BAAuB;ARDhB,SAAS,kBACX,SACiC;AACpC,SAAO,QAAQ;IACb,CAAC,iBAAiB,oBAAoB;MACpC,GAAG;MACH,GAAI,kBAAA,OAAA,iBAAkB,CAAC;IACzB;IACA,CAAC;EACH;AACF;AEJO,SAAS,uBACd,UACwB;AACxB,QAAM,UAAkC,CAAC;AACzC,WAAS,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AACvC,YAAQ,GAAG,IAAI;EACjB,CAAC;AACD,SAAO;AACT;ACTO,IAAM,aAAa;EACxB;EACA;AACF;AERO,SAAS,aAAa,OAAgC;AAC3D,SACE,iBAAiB,UAChB,MAAM,SAAS,gBAAgB,MAAM,SAAS;AAEnD;ACHO,SAAS,WAAW;EACzB;EACA;EACA,sBAAsB;EACtB;AACF,GAKW;AACT,MAAI,OAAO,WAAW,UAAU;AAC9B,WAAO;EACT;AAEA,MAAI,UAAU,MAAM;AAClB,UAAM,IAAI,gBAAgB;MACxB,SAAS,GAAG,WAAW;IACzB,CAAC;EACH;AAEA,MAAI,OAAO,YAAY,aAAa;AAClC,UAAM,IAAI,gBAAgB;MACxB,SAAS,GAAG,WAAW,2CAA2C,mBAAmB;IACvF,CAAC;EACH;AAEA,WAAS,QAAQ,IAAI,uBAAuB;AAE5C,MAAI,UAAU,MAAM;AAClB,UAAM,IAAI,gBAAgB;MACxB,SAAS,GAAG,WAAW,2CAA2C,mBAAmB,sBAAsB,uBAAuB;IACpI,CAAC;EACH;AAEA,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,gBAAgB;MACxB,SAAS,GAAG,WAAW,+CAA+C,uBAAuB;IAC/F,CAAC;EACH;AAEA,SAAO;AACT;AIvCO,IAAM,kBAAkB,OAAO,IAAI,qBAAqB;AAsBxD,SAAS,UACd,UAGmB;AACnB,SAAO,EAAE,CAAC,eAAe,GAAG,MAAM,SAAS;AAC7C;AAEO,SAAS,YAAY,OAAoC;AAC9D,SACE,OAAO,UAAU,YACjB,UAAU,QACV,mBAAmB,SACnB,MAAM,eAAe,MAAM,QAC3B,cAAc;AAElB;AAEO,SAAS,aACd,WACmB;AACnB,SAAO,UAAU,CAAA,UAAS;AACxB,UAAM,SAAS,UAAU,UAAU,KAAK;AACxC,WAAO,OAAO,UACV,EAAE,SAAS,MAAM,OAAO,OAAO,KAAK,IACpC,EAAE,SAAS,OAAO,OAAO,OAAO,MAAM;EAC5C,CAAC;AACH;ADzCO,SAAS,cAAiB;EAC/B;EACA,QAAQ;AACV,GAGM;AACJ,QAAM,SAAS,kBAAkB,EAAE,OAAO,QAAQ,YAAY,CAAC;AAE/D,MAAI,CAAC,OAAO,SAAS;AACnB,UAAM,IAAI,oBAAoB,EAAE,OAAO,OAAO,OAAO,MAAM,CAAC;EAC9D;AAEA,SAAO,OAAO;AAChB;AAWO,SAAS,kBAAqB;EACnC;EACA,QAAQ;AACV,GAKmD;AACjD,QAAM,SAAS,YAAY,WAAW,IAClC,cACA,aAAa,WAAW;AAE5B,MAAI;AACF,QAAI,OAAO,YAAY,MAAM;AAC3B,aAAO,EAAE,SAAS,MAAM,MAAkB;IAC5C;AAEA,UAAM,mBAAmB,OAAO,SAAS,KAAK;AAE9C,QAAI,iBAAiB,SAAS;AAC5B,aAAO;IACT;AAEA,WAAO;MACL,SAAS;MACT,OAAO,IAAI,oBAAoB;QAC7B;QACA,OAAO,iBAAiB;MAC1B,CAAC;IACH;EACF,SAAS,OAAO;AACd,WAAO;MACL,SAAS;MACT,OAAO,oBAAoB,sBAAsB,KAAK,IAClD,QACA,IAAI,oBAAoB,EAAE,OAAO,OAAO,MAAM,CAAC;IACrD;EACF;AACF;ADjDO,SAAS,UAAa;EAC3B;EACA;AACF,GAGM;AACJ,MAAI;AACF,UAAM,QAAQ,yBAAAG,QAAW,MAAM,IAAI;AAEnC,QAAI,UAAU,MAAM;AAClB,aAAO;IACT;AAEA,WAAO,cAAc,EAAE,OAAO,OAAO,CAAC;EACxC,SAAS,OAAO;AACd,QACE,eAAe,iBAAiB,KAAK,KACrCC,oBAAoB,sBAAsB,KAAK,GAC/C;AACA,YAAM;IACR;AAEA,UAAM,IAAI,eAAe,EAAE,MAAM,OAAO,MAAM,CAAC;EACjD;AACF;AA4BO,SAAS,cAAiB;EAC/B;EACA;AACF,GAKoE;AAClE,MAAI;AACF,UAAM,QAAQ,yBAAAD,QAAW,MAAM,IAAI;AAEnC,QAAI,UAAU,MAAM;AAClB,aAAO;QACL,SAAS;QACT;MACF;IACF;AAEA,WAAO,kBAAkB,EAAE,OAAO,OAAO,CAAC;EAC5C,SAAS,OAAO;AACd,WAAO;MACL,SAAS;MACT,OAAO,eAAe,iBAAiB,KAAK,IACxC,QACA,IAAI,eAAe,EAAE,MAAM,OAAO,MAAM,CAAC;IAC/C;EACF;AACF;AI7GO,SAAS,uBACd,QACmB;AACnB,SAAO,OAAO;IACZ,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,CAAC,MAAM,KAAK,MAAM,SAAS,IAAI;EAChE;AACF;ADCA,IAAM,mBAAmB,MAAM;AAExB,IAAM,gBAAgB,OAAU;EACrC;EACA;EACA;EACA;EACA;EACA;EACA,OAAAE;AACF,MASE,UAAU;EACR;EACA,SAAS;IACP,gBAAgB;IAChB,GAAG;EACL;EACA,MAAM;IACJ,SAAS,KAAK,UAAU,IAAI;IAC5B,QAAQ;EACV;EACA;EACA;EACA;EACA,OAAAA;AACF,CAAC;AAEI,IAAM,YAAY,OAAU;EACjC;EACA,UAAU,CAAC;EACX;EACA;EACA;EACA;EACA,OAAAA,SAAQ,iBAAiB;AAC3B,MAWM;AACJ,MAAI;AACF,UAAM,WAAW,MAAMA,OAAM,KAAK;MAChC,QAAQ;MACR,SAAS,uBAAuB,OAAO;MACvC,MAAM,KAAK;MACX,QAAQ;IACV,CAAC;AAED,UAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,QAAI,CAAC,SAAS,IAAI;AAChB,UAAI;AAKJ,UAAI;AACF,2BAAmB,MAAM,sBAAsB;UAC7C;UACA;UACA,mBAAmB,KAAK;QAC1B,CAAC;MACH,SAAS,OAAO;AACd,YAAI,aAAa,KAAK,KAAK,aAAa,eAAe,KAAK,GAAG;AAC7D,gBAAM;QACR;AAEA,cAAM,IAAI,aAAa;UACrB,SAAS;UACT,OAAO;UACP,YAAY,SAAS;UACrB;UACA;UACA,mBAAmB,KAAK;QAC1B,CAAC;MACH;AAEA,YAAM,iBAAiB;IACzB;AAEA,QAAI;AACF,aAAO,MAAM,0BAA0B;QACrC;QACA;QACA,mBAAmB,KAAK;MAC1B,CAAC;IACH,SAAS,OAAO;AACd,UAAI,iBAAiB,OAAO;AAC1B,YAAI,aAAa,KAAK,KAAK,aAAa,eAAe,KAAK,GAAG;AAC7D,gBAAM;QACR;MACF;AAEA,YAAM,IAAI,aAAa;QACrB,SAAS;QACT,OAAO;QACP,YAAY,SAAS;QACrB;QACA;QACA,mBAAmB,KAAK;MAC1B,CAAC;IACH;EACF,SAAS,OAAO;AACd,QAAI,aAAa,KAAK,GAAG;AACvB,YAAM;IACR;AAGA,QAAI,iBAAiB,aAAa,MAAM,YAAY,gBAAgB;AAClE,YAAM,QAAS,MAAc;AAE7B,UAAI,SAAS,MAAM;AAEjB,cAAM,IAAI,aAAa;UACrB,SAAS,0BAA0B,MAAM,OAAO;UAChD;UACA;UACA,mBAAmB,KAAK;UACxB,aAAa;;QACf,CAAC;MACH;IACF;AAEA,UAAM;EACR;AACF;AEjIO,IAAM,iCACX,CAAI;EACF;EACA;EACA;AACF,MAKA,OAAO,EAAE,UAAU,KAAK,kBAAkB,MAAM;AAC9C,QAAM,eAAe,MAAM,SAAS,KAAK;AACzC,QAAM,kBAAkB,uBAAuB,QAAQ;AAGvD,MAAI,aAAa,KAAK,MAAM,IAAI;AAC9B,WAAO;MACL;MACA,OAAO,IAAIC,aAAa;QACtB,SAAS,SAAS;QAClB;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,aAAa,eAAA,OAAA,SAAA,YAAc,QAAA;MAC7B,CAAC;IACH;EACF;AAGA,MAAI;AACF,UAAM,cAAc,UAAU;MAC5B,MAAM;MACN,QAAQ;IACV,CAAC;AAED,WAAO;MACL;MACA,OAAO,IAAIA,aAAa;QACtB,SAAS,eAAe,WAAW;QACnC;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,MAAM;QACN,aAAa,eAAA,OAAA,SAAA,YAAc,UAAU,WAAA;MACvC,CAAC;IACH;EACF,SAAS,YAAY;AACnB,WAAO;MACL;MACA,OAAO,IAAIA,aAAa;QACtB,SAAS,SAAS;QAClB;QACA;QACA,YAAY,SAAS;QACrB;QACA;QACA,aAAa,eAAA,OAAA,SAAA,YAAc,QAAA;MAC7B,CAAC;IACH;EACF;AACF;AAEK,IAAM,mCACX,CACE,gBAEF,OAAO,EAAE,SAAS,MAA8B;AAC9C,QAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,MAAI,SAAS,QAAQ,MAAM;AACzB,UAAM,IAAI,uBAAuB,CAAC,CAAC;EACrC;AAEA,SAAO;IACL;IACA,OAAO,SAAS,KACb,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,wBAAwB,CAAC,EACzC;MACC,IAAI,gBAA6C;QAC/C,UAAU,EAAE,KAAK,GAAG,YAAY;AAE9B,cAAI,SAAS,UAAU;AACrB;UACF;AAEA,qBAAW;YACT,cAAc;cACZ,MAAM;cACN,QAAQ;YACV,CAAC;UACH;QACF;MACF,CAAC;IACH;EACJ;AACF;AAqCK,IAAM,4BACX,CAAI,mBACJ,OAAO,EAAE,UAAU,KAAK,kBAAkB,MAAM;AAC9C,QAAM,eAAe,MAAM,SAAS,KAAK;AAEzC,QAAM,eAAe,cAAc;IACjC,MAAM;IACN,QAAQ;EACV,CAAC;AAED,QAAM,kBAAkB,uBAAuB,QAAQ;AAEvD,MAAI,CAAC,aAAa,SAAS;AACzB,UAAM,IAAIC,aAAa;MACrB,SAAS;MACT,OAAO,aAAa;MACpB,YAAY,SAAS;MACrB;MACA;MACA;MACA;IACF,CAAC;EACH;AAEA,SAAO;IACL;IACA,OAAO,aAAa;EACtB;AACF;ACjLK,SAAS,0BAA0B,OAA2B;AACnE,MAAI,eAAe;AAInB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,oBAAgB,OAAO,cAAc,MAAM,CAAC,CAAC;EAC/C;AAEA,SAAO,WAAW,KAAK,YAAY;AACrC;AChBO,SAAS,qBAAqB,KAAyB;AAC5D,SAAO,OAAA,OAAA,SAAA,IAAK,QAAQ,OAAO,EAAA;AAC7B;;;AGCA,IAAM,2BAA2B,EAAE,OAAO;EACxC,MAAM,EAAE,QAAQ,OAAO;EACvB,OAAO,EAAE,OAAO;IACd,MAAM,EAAE,OAAO;IACf,SAAS,EAAE,OAAO;EACpB,CAAC;AACH,CAAC;AAIM,IAAM,iCAAiC,+BAA+B;EAC3E,aAAa;EACb,gBAAgB,CAAA,SAAQ,KAAK,MAAM;AACrC,CAAC;ACHM,SAAS,iCACdC,SACyB;AAf3B,MAAAC;AAgBE,QAAM,SAAS,gBAAgBD,OAAM;AAErC,MAAI,SAA6B;AACjC,QAAM,WAA+B,CAAC;AAEtC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,QAAQ,OAAO,CAAC;AACtB,UAAM,OAAO,MAAM;AAEnB,YAAQ,MAAM;MACZ,KAAK,UAAU;AACb,YAAI,UAAU,MAAM;AAClB,gBAAM,IAAI,8BAA8B;YACtC,eACE;UACJ,CAAC;QACH;AAEA,iBAAS,MAAM,SAAS,IAAI,CAAC,EAAE,QAAQ,MAAM,OAAO,EAAE,KAAK,IAAI;AAC/D;MACF;MAEA,KAAK,QAAQ;AAEX,cAAM,mBAAoD,CAAC;AAE3D,mBAAW,EAAE,MAAM,QAAQ,KAAK,MAAM,UAAU;AAC9C,kBAAQ,MAAM;YACZ,KAAK,QAAQ;AACX,yBAAW,QAAQ,SAAS;AAC1B,wBAAQ,KAAK,MAAM;kBACjB,KAAK,QAAQ;AACX,qCAAiB,KAAK,EAAE,MAAM,QAAQ,MAAM,KAAK,KAAK,CAAC;AACvD;kBACF;kBACA,KAAK,SAAS;AACZ,wBAAI,KAAK,iBAAiB,KAAK;AAE7B,4BAAM,IAAI,8BAA8B;wBACtC,eAAe;sBACjB,CAAC;oBACH;AAEA,qCAAiB,KAAK;sBACpB,MAAM;sBACN,QAAQ;wBACN,MAAM;wBACN,aAAYC,OAAA,KAAK,aAAL,OAAAA,OAAiB;wBAC7B,MAAM,0BAA0B,KAAK,KAAK;sBAC5C;oBACF,CAAC;AAED;kBACF;gBACF;cACF;AAEA;YACF;YACA,KAAK,QAAQ;AACX,yBAAW,QAAQ,SAAS;AAC1B,iCAAiB,KAAK;kBACpB,MAAM;kBACN,aAAa,KAAK;kBAClB,SAAS,KAAK,UAAU,KAAK,MAAM;kBACnC,UAAU,KAAK;gBACjB,CAAC;cACH;AAEA;YACF;YACA,SAAS;AACP,oBAAM,mBAA0B;AAChC,oBAAM,IAAI,MAAM,qBAAqB,gBAAgB,EAAE;YACzD;UACF;QACF;AAEA,iBAAS,KAAK,EAAE,MAAM,QAAQ,SAAS,iBAAiB,CAAC;AAEzD;MACF;MAEA,KAAK,aAAa;AAEhB,cAAM,mBAAyD,CAAC;AAEhE,mBAAW,EAAE,QAAQ,KAAK,MAAM,UAAU;AACxC,mBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,kBAAM,OAAO,QAAQ,CAAC;AACtB,oBAAQ,KAAK,MAAM;cACjB,KAAK,QAAQ;AACX,iCAAiB,KAAK;kBACpB,MAAM;kBACN;;;;oBAIE,MAAM,OAAO,SAAS,KAAK,MAAM,MAAM,SAAS,SAAS,IACrD,KAAK,KAAK,KAAK,IACf,KAAK;;gBACb,CAAC;AACD;cACF;cAEA,KAAK,aAAa;AAChB,iCAAiB,KAAK;kBACpB,MAAM;kBACN,IAAI,KAAK;kBACT,MAAM,KAAK;kBACX,OAAO,KAAK;gBACd,CAAC;AACD;cACF;YACF;UACF;QACF;AAEA,iBAAS,KAAK,EAAE,MAAM,aAAa,SAAS,iBAAiB,CAAC;AAE9D;MACF;MAEA,SAAS;AACP,cAAM,mBAA0B;AAChC,cAAM,IAAI,MAAM,qBAAqB,gBAAgB,EAAE;MACzD;IACF;EACF;AAEA,SAAO;IACL;IACA;EACF;AACF;AAeA,SAAS,gBACPD,SACiD;AACjD,QAAM,SAA0D,CAAC;AACjE,MAAI,eACF;AAEF,aAAW,EAAE,MAAM,QAAQ,KAAKA,SAAQ;AACtC,YAAQ,MAAM;MACZ,KAAK,UAAU;AACb,aAAI,gBAAA,OAAA,SAAA,aAAc,UAAS,UAAU;AACnC,yBAAe,EAAE,MAAM,UAAU,UAAU,CAAC,EAAE;AAC9C,iBAAO,KAAK,YAAY;QAC1B;AAEA,qBAAa,SAAS,KAAK,EAAE,MAAM,QAAQ,CAAC;AAC5C;MACF;MACA,KAAK,aAAa;AAChB,aAAI,gBAAA,OAAA,SAAA,aAAc,UAAS,aAAa;AACtC,yBAAe,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE;AACjD,iBAAO,KAAK,YAAY;QAC1B;AAEA,qBAAa,SAAS,KAAK,EAAE,MAAM,QAAQ,CAAC;AAC5C;MACF;MACA,KAAK,QAAQ;AACX,aAAI,gBAAA,OAAA,SAAA,aAAc,UAAS,QAAQ;AACjC,yBAAe,EAAE,MAAM,QAAQ,UAAU,CAAC,EAAE;AAC5C,iBAAO,KAAK,YAAY;QAC1B;AAEA,qBAAa,SAAS,KAAK,EAAE,MAAM,QAAQ,CAAC;AAC5C;MACF;MACA,KAAK,QAAQ;AACX,aAAI,gBAAA,OAAA,SAAA,aAAc,UAAS,QAAQ;AACjC,yBAAe,EAAE,MAAM,QAAQ,UAAU,CAAC,EAAE;AAC5C,iBAAO,KAAK,YAAY;QAC1B;AAEA,qBAAa,SAAS,KAAK,EAAE,MAAM,QAAQ,CAAC;AAC5C;MACF;MACA,SAAS;AACP,cAAM,mBAA0B;AAChC,cAAM,IAAI,MAAM,qBAAqB,gBAAgB,EAAE;MACzD;IACF;EACF;AAEA,SAAO;AACT;ACxNO,SAAS,uBACd,cAC6B;AAC7B,UAAQ,cAAc;IACpB,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IACT;AACE,aAAO;EACX;AACF;AHeO,IAAM,iCAAN,MAAgE;EAUrE,YACE,SACA,UACA,QACA;AAbF,SAAS,uBAAuB;AAChC,SAAS,8BAA8B;AACvC,SAAS,oBAAoB;AAY3B,SAAK,UAAU;AACf,SAAK,WAAW;AAChB,SAAK,SAAS;EAChB;EAEA,IAAI,WAAmB;AACrB,WAAO,KAAK,OAAO;EACrB;EAEA,MAAc,QAAQ;IACpB;IACA,QAAAA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACF,GAAiD;AAC/C,UAAM,OAAO,KAAK;AAElB,UAAM,WAAyC,CAAC;AAEhD,QAAI,oBAAoB,MAAM;AAC5B,eAAS,KAAK;QACZ,MAAM;QACN,SAAS;MACX,CAAC;IACH;AAEA,QAAI,mBAAmB,MAAM;AAC3B,eAAS,KAAK;QACZ,MAAM;QACN,SAAS;MACX,CAAC;IACH;AAEA,QAAI,QAAQ,MAAM;AAChB,eAAS,KAAK;QACZ,MAAM;QACN,SAAS;MACX,CAAC;IACH;AAEA,QAAI,kBAAkB,QAAQ,eAAe,SAAS,QAAQ;AAC5D,eAAS,KAAK;QACZ,MAAM;QACN,SAAS;QACT,SAAS;MACX,CAAC;IACH;AAEA,UAAM,iBAAiB,iCAAiCA,OAAM;AAE9D,UAAM,WAAW;;MAEf,OAAO,KAAK;;MAGZ,OAAO,QAAA,OAAA,OAAQ,KAAK,SAAS;;MAG7B,YAAY,aAAA,OAAA,YAAa;;MACzB;MACA,OAAO;MACP,gBAAgB;;MAGhB,QAAQ,eAAe;MACvB,UAAU,eAAe;IAC3B;AAEA,YAAQ,MAAM;MACZ,KAAK,WAAW;AACd,eAAO;UACL,MAAM,EAAE,GAAG,UAAU,GAAG,0BAA0B,IAAI,EAAE;UACxD;QACF;MACF;MAEA,KAAK,eAAe;AAClB,cAAM,IAAIE,8BAA8B;UACtC,eAAe;QACjB,CAAC;MACH;MAEA,KAAK,eAAe;AAClB,cAAM,EAAE,MAAAC,QAAM,aAAa,WAAW,IAAI,KAAK;AAE/C,eAAO;UACL,MAAM;YACJ,GAAG;YACH,OAAO,CAAC,EAAE,MAAAA,QAAM,aAAa,cAAc,WAAW,CAAC;YACvD,aAAa,EAAE,MAAM,QAAQ,MAAAA,OAAK;UACpC;UACA;QACF;MACF;MAEA,SAAS;AACP,cAAM,mBAA0B;AAChC,cAAM,IAAI,MAAM,qBAAqB,gBAAgB,EAAE;MACzD;IACF;EACF;EAEA,MAAM,WACJ,SAC6D;AAC7D,UAAM,EAAE,MAAM,SAAS,IAAI,MAAM,KAAK,QAAQ,OAAO;AAErD,UAAM,EAAE,iBAAiB,OAAO,SAAS,IAAI,MAAM,cAAc;MAC/D,KAAK,GAAG,KAAK,OAAO,OAAO;MAC3B,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;MAC9D,MAAM;MACN,uBAAuB;MACvB,2BAA2B;QACzB;MACF;MACA,aAAa,QAAQ;MACrB,OAAO,KAAK,OAAO;IACrB,CAAC;AAED,UAAM,EAAE,UAAU,WAAW,GAAG,YAAY,IAAI;AAGhD,QAAI,OAAO;AACX,eAAW,WAAW,SAAS,SAAS;AACtC,UAAI,QAAQ,SAAS,QAAQ;AAC3B,gBAAQ,QAAQ;MAClB;IACF;AAGA,QAAI,YAA2D;AAC/D,QAAI,SAAS,QAAQ,KAAK,CAAA,YAAW,QAAQ,SAAS,UAAU,GAAG;AACjE,kBAAY,CAAC;AACb,iBAAW,WAAW,SAAS,SAAS;AACtC,YAAI,QAAQ,SAAS,YAAY;AAC/B,oBAAU,KAAK;YACb,cAAc;YACd,YAAY,QAAQ;YACpB,UAAU,QAAQ;YAClB,MAAM,KAAK,UAAU,QAAQ,KAAK;UACpC,CAAC;QACH;MACF;IACF;AAEA,WAAO;MACL;MACA;MACA,cAAc,uBAAuB,SAAS,WAAW;MACzD,OAAO;QACL,cAAc,SAAS,MAAM;QAC7B,kBAAkB,SAAS,MAAM;MACnC;MACA,SAAS,EAAE,WAAW,YAAY;MAClC,aAAa,EAAE,SAAS,gBAAgB;MACxC;IACF;EACF;EAEA,MAAM,SACJ,SAC2D;AAC3D,UAAM,EAAE,MAAM,SAAS,IAAI,MAAM,KAAK,QAAQ,OAAO;AAErD,UAAM,EAAE,iBAAiB,OAAO,SAAS,IAAI,MAAM,cAAc;MAC/D,KAAK,GAAG,KAAK,OAAO,OAAO;MAC3B,SAAS,eAAe,KAAK,OAAO,QAAQ,GAAG,QAAQ,OAAO;MAC9D,MAAM;QACJ,GAAG;QACH,QAAQ;MACV;MACA,uBAAuB;MACvB,2BAA2B;QACzB;MACF;MACA,aAAa,QAAQ;MACrB,OAAO,KAAK,OAAO;IACrB,CAAC;AAED,UAAM,EAAE,UAAU,WAAW,GAAG,YAAY,IAAI;AAEhD,QAAI,eAA4C;AAChD,UAAM,QAA4D;MAChE,cAAc,OAAO;MACrB,kBAAkB,OAAO;IAC3B;AAEA,UAAM,wBAOF,CAAC;AAEL,WAAO;MACL,QAAQ,SAAS;QACf,IAAI,gBAGF;UACA,UAAU,OAAO,YAAY;AAC3B,gBAAI,CAAC,MAAM,SAAS;AAClB,yBAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;YACF;AAEA,kBAAM,QAAQ,MAAM;AAEpB,oBAAQ,MAAM,MAAM;cAClB,KAAK,QAAQ;AACX;cACF;cAEA,KAAK,uBAAuB;AAC1B,sBAAM,mBAAmB,MAAM,cAAc;AAE7C,wBAAQ,kBAAkB;kBACxB,KAAK,QAAQ;AACX;kBACF;kBAEA,KAAK,YAAY;AACf,0CAAsB,MAAM,KAAK,IAAI;sBACnC,YAAY,MAAM,cAAc;sBAChC,UAAU,MAAM,cAAc;sBAC9B,UAAU;oBACZ;AACA;kBACF;kBAEA,SAAS;AACP,0BAAM,mBAA0B;AAChC,0BAAM,IAAI;sBACR,mCAAmC,gBAAgB;oBACrD;kBACF;gBACF;cACF;cAEA,KAAK,sBAAsB;AAEzB,oBAAI,sBAAsB,MAAM,KAAK,KAAK,MAAM;AAC9C,wBAAM,eAAe,sBAAsB,MAAM,KAAK;AAEtD,6BAAW,QAAQ;oBACjB,MAAM;oBACN,cAAc;oBACd,YAAY,aAAa;oBACzB,UAAU,aAAa;oBACvB,MAAM,aAAa;kBACrB,CAAC;AAED,yBAAO,sBAAsB,MAAM,KAAK;gBAC1C;AAEA;cACF;cAEA,KAAK,uBAAuB;AAC1B,sBAAM,YAAY,MAAM,MAAM;AAC9B,wBAAQ,WAAW;kBACjB,KAAK,cAAc;AACjB,+BAAW,QAAQ;sBACjB,MAAM;sBACN,WAAW,MAAM,MAAM;oBACzB,CAAC;AAED;kBACF;kBAEA,KAAK,oBAAoB;AACvB,0BAAM,eAAe,sBAAsB,MAAM,KAAK;AAEtD,+BAAW,QAAQ;sBACjB,MAAM;sBACN,cAAc;sBACd,YAAY,aAAa;sBACzB,UAAU,aAAa;sBACvB,eAAe,MAAM,MAAM;oBAC7B,CAAC;AAED,iCAAa,YAAY,MAAM,MAAM;AAErC;kBACF;kBAEA,SAAS;AACP,0BAAM,mBAA0B;AAChC,0BAAM,IAAI;sBACR,2BAA2B,gBAAgB;oBAC7C;kBACF;gBACF;cACF;cAEA,KAAK,iBAAiB;AACpB,sBAAM,eAAe,MAAM,QAAQ,MAAM;AACzC,sBAAM,mBAAmB,MAAM,QAAQ,MAAM;AAC7C;cACF;cAEA,KAAK,iBAAiB;AACpB,sBAAM,mBAAmB,MAAM,MAAM;AACrC,+BAAe,uBAAuB,MAAM,MAAM,WAAW;AAC7D;cACF;cAEA,KAAK,gBAAgB;AACnB,2BAAW,QAAQ,EAAE,MAAM,UAAU,cAAc,MAAM,CAAC;AAC1D;cACF;cAEA,KAAK,SAAS;AACZ,2BAAW,QAAQ,EAAE,MAAM,SAAS,OAAO,MAAM,MAAM,CAAC;AACxD;cACF;cAEA,SAAS;AACP,sBAAM,mBAA0B;AAChC,sBAAM,IAAI,MAAM,2BAA2B,gBAAgB,EAAE;cAC/D;YACF;UACF;QACF,CAAC;MACH;MACA,SAAS,EAAE,WAAW,YAAY;MAClC,aAAa,EAAE,SAAS,gBAAgB;MACxC;IACF;EACF;AACF;AAIA,IAAM,kCAAkCC,EAAE,OAAO;EAC/C,MAAMA,EAAE,QAAQ,SAAS;EACzB,SAASA,EAAE;IACTA,EAAE,mBAAmB,QAAQ;MAC3BA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,MAAM;QACtB,MAAMA,EAAE,OAAO;MACjB,CAAC;MACDA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,UAAU;QAC1B,IAAIA,EAAE,OAAO;QACb,MAAMA,EAAE,OAAO;QACf,OAAOA,EAAE,QAAQ;MACnB,CAAC;IACH,CAAC;EACH;EACA,aAAaA,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS;EAC5C,OAAOA,EAAE,OAAO;IACd,cAAcA,EAAE,OAAO;IACvB,eAAeA,EAAE,OAAO;EAC1B,CAAC;AACH,CAAC;AAID,IAAM,+BAA+BA,EAAE,mBAAmB,QAAQ;EAChEA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,eAAe;IAC/B,SAASA,EAAE,OAAO;MAChB,OAAOA,EAAE,OAAO;QACd,cAAcA,EAAE,OAAO;QACvB,eAAeA,EAAE,OAAO;MAC1B,CAAC;IACH,CAAC;EACH,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,qBAAqB;IACrC,OAAOA,EAAE,OAAO;IAChB,eAAeA,EAAE,mBAAmB,QAAQ;MAC1CA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,MAAM;QACtB,MAAMA,EAAE,OAAO;MACjB,CAAC;MACDA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,UAAU;QAC1B,IAAIA,EAAE,OAAO;QACb,MAAMA,EAAE,OAAO;MACjB,CAAC;IACH,CAAC;EACH,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,qBAAqB;IACrC,OAAOA,EAAE,OAAO;IAChB,OAAOA,EAAE,mBAAmB,QAAQ;MAClCA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,kBAAkB;QAClC,cAAcA,EAAE,OAAO;MACzB,CAAC;MACDA,EAAE,OAAO;QACP,MAAMA,EAAE,QAAQ,YAAY;QAC5B,MAAMA,EAAE,OAAO;MACjB,CAAC;IACH,CAAC;EACH,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,oBAAoB;IACpC,OAAOA,EAAE,OAAO;EAClB,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,OAAO;IACvB,OAAOA,EAAE,OAAO;MACd,MAAMA,EAAE,OAAO;MACf,SAASA,EAAE,OAAO;IACpB,CAAC;EACH,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,eAAe;IAC/B,OAAOA,EAAE,OAAO,EAAE,aAAaA,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;IACjE,OAAOA,EAAE,OAAO,EAAE,eAAeA,EAAE,OAAO,EAAE,CAAC;EAC/C,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,cAAc;EAChC,CAAC;EACDA,EAAE,OAAO;IACP,MAAMA,EAAE,QAAQ,MAAM;EACxB,CAAC;AACH,CAAC;AAED,SAAS,0BACP,MAGA;AAjeF,MAAAH;AAmeE,QAAM,UAAQA,OAAA,KAAK,UAAL,OAAA,SAAAA,KAAY,UAAS,KAAK,QAAQ;AAEhD,MAAI,SAAS,MAAM;AACjB,WAAO,EAAE,OAAO,QAAW,aAAa,OAAU;EACpD;AAEA,QAAM,cAAc,MAAM,IAAI,CAAA,UAAS;IACrC,MAAM,KAAK;IACX,aAAa,KAAK;IAClB,cAAc,KAAK;EACrB,EAAE;AAEF,QAAM,aAAa,KAAK;AAExB,MAAI,cAAc,MAAM;AACtB,WAAO,EAAE,OAAO,aAAa,aAAa,OAAU;EACtD;AAEA,QAAM,OAAO,WAAW;AAExB,UAAQ,MAAM;IACZ,KAAK;AACH,aAAO,EAAE,OAAO,aAAa,aAAa,EAAE,MAAM,OAAO,EAAE;IAC7D,KAAK;AACH,aAAO,EAAE,OAAO,aAAa,aAAa,EAAE,MAAM,MAAM,EAAE;IAC5D,KAAK;AAEH,aAAO,EAAE,OAAO,QAAW,aAAa,OAAU;IACpD,KAAK;AACH,aAAO;QACL,OAAO;QACP,aAAa,EAAE,MAAM,QAAQ,MAAM,WAAW,SAAS;MACzD;IACF,SAAS;AACP,YAAM,mBAA0B;AAChC,YAAM,IAAI,MAAM,iCAAiC,gBAAgB,EAAE;IACrE;EACF;AACF;AD9fO,IAAM,YAAN,MAAgB;;;;EAarB,YAAY,UAAqC,CAAC,GAAG;AAxBvD,QAAAA,MAAA;AAyBI,SAAK,WACH,KAAA,sBAAqBA,OAAA,QAAQ,YAAR,OAAAA,OAAmB,QAAQ,OAAO,MAAvD,OAAA,KACA;AACF,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ;EACzB;EAEA,IAAY,aAAa;AACvB,WAAO;MACL,SAAS,KAAK;MACd,SAAS,OAAO;QACd,qBAAqB;QACrB,kBAAkB;QAClB,aAAa,WAAW;UACtB,QAAQ,KAAK;UACb,yBAAyB;UACzB,aAAa;QACf,CAAC;QACD,GAAG,KAAK;MACV;IACF;EACF;;;;EAKA,SACE,SACA,WAAsC,CAAC,GACvC;AACA,WAAO,KAAK,KAAK,SAAS,QAAQ;EACpC;EAEA,KACE,SACA,WAAsC,CAAC,GACvC;AACA,WAAO,IAAI,+BAA+B,SAAS,UAAU;MAC3D,UAAU;MACV,GAAG,KAAK;IACV,CAAC;EACH;AACF;AKSO,SAAS,gBACd,UAAqC,CAAC,GACnB;AA9ErB,MAAAA,MAAA;AA+EE,QAAM,WACJ,KAAAI,sBAAqBJ,OAAA,QAAQ,YAAR,OAAAA,OAAmB,QAAQ,OAAO,MAAvD,OAAA,KACA;AAEF,QAAM,aAAa,OAAO;IACxB,qBAAqB;IACrB,aAAaK,WAAW;MACtB,QAAQ,QAAQ;MAChB,yBAAyB;MACzB,aAAa;IACf,CAAC;IACD,GAAG,QAAQ;EACb;AAEA,QAAM,kBAAkB,CACtB,SACA,WAAsC,CAAC,MAEvC,IAAI,+BAA+B,SAAS,UAAU;IACpD,UAAU;IACV;IACA,SAAS;IACT,OAAO,QAAQ;EACjB,CAAC;AAEH,QAAM,WAAW,SACf,SACA,UACA;AACA,QAAI,YAAY;AACd,YAAM,IAAI;QACR;MACF;IACF;AAEA,WAAO,gBAAgB,SAAS,QAAQ;EAC1C;AAEA,WAAS,gBAAgB;AACzB,WAAS,OAAO;AAChB,WAAS,WAAW;AAEpB,SAAO;AACT;AAKO,IAAM,YAAY,gBAAgB;",
  "names": ["_AISDKError", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "SecureJSON", "TypeValidationError", "fetch", "APICallError", "APICallError", "prompt", "_a", "UnsupportedFunctionalityError", "name", "z", "withoutTrailingSlash", "loadApiKey"]
}
