{"version":3,"sources":["../src/cohere-provider.ts","../src/cohere-chat-language-model.ts","../src/cohere-error.ts","../src/convert-to-cohere-chat-prompt.ts","../src/map-cohere-finish-reason.ts","../src/cohere-prepare-tools.ts","../src/cohere-embedding-model.ts"],"sourcesContent":["import {\n  EmbeddingModelV1,\n  LanguageModelV1,\n  ProviderV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { CohereChatLanguageModel } from './cohere-chat-language-model';\nimport { CohereChatModelId, CohereChatSettings } from './cohere-chat-settings';\nimport { CohereEmbeddingModel } from './cohere-embedding-model';\nimport {\n  CohereEmbeddingModelId,\n  CohereEmbeddingSettings,\n} from './cohere-embedding-settings';\n\nexport interface CohereProvider extends ProviderV1 {\n  (modelId: CohereChatModelId, settings?: CohereChatSettings): LanguageModelV1;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(\n    modelId: CohereChatModelId,\n    settings?: CohereChatSettings,\n  ): LanguageModelV1;\n\n  embedding(\n    modelId: CohereEmbeddingModelId,\n    settings?: CohereEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  textEmbeddingModel(\n    modelId: CohereEmbeddingModelId,\n    settings?: CohereEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n}\n\nexport interface CohereProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://api.cohere.com/v2`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being send using the `Authorization` header.\nIt defaults to the `COHERE_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n}\n\n/**\nCreate a Cohere AI provider instance.\n */\nexport function createCohere(\n  options: CohereProviderSettings = {},\n): CohereProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.cohere.com/v2';\n\n  const getHeaders = () => ({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'COHERE_API_KEY',\n      description: 'Cohere',\n    })}`,\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: CohereChatModelId,\n    settings: CohereChatSettings = {},\n  ) =>\n    new CohereChatLanguageModel(modelId, settings, {\n      provider: 'cohere.chat',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createTextEmbeddingModel = (\n    modelId: CohereEmbeddingModelId,\n    settings: CohereEmbeddingSettings = {},\n  ) =>\n    new CohereEmbeddingModel(modelId, settings, {\n      provider: 'cohere.textEmbedding',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (\n    modelId: CohereChatModelId,\n    settings?: CohereChatSettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Cohere model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.embedding = createTextEmbeddingModel;\n  provider.textEmbeddingModel = createTextEmbeddingModel;\n\n  return provider as CohereProvider;\n}\n\n/**\nDefault Cohere provider instance.\n */\nexport const cohere = createCohere();\n","import {\n  LanguageModelV1,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport {\n  CohereChatModelId,\n  CohereChatSettings,\n} from '../src/cohere-chat-settings';\nimport { cohereFailedResponseHandler } from '../src/cohere-error';\nimport { convertToCohereChatPrompt } from '../src/convert-to-cohere-chat-prompt';\nimport { mapCohereFinishReason } from '../src/map-cohere-finish-reason';\nimport { prepareTools } from './cohere-prepare-tools';\nimport {\n  CohereChatPrompt,\n  CohereAssistantMessage,\n  CohereUserMessage,\n  CohereSystemMessage,\n} from './cohere-chat-prompt';\n\ntype CohereChatConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class CohereChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: CohereChatModelId;\n  readonly settings: CohereChatSettings;\n\n  private readonly config: CohereChatConfig;\n\n  constructor(\n    modelId: CohereChatModelId,\n    settings: CohereChatSettings,\n    config: CohereChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const chatPrompt = convertToCohereChatPrompt(prompt);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      // none\n\n      // standardized settings:\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      max_tokens: maxTokens,\n      temperature,\n      p: topP,\n      k: topK,\n      seed,\n      stop_sequences: stopSequences,\n\n      // response format:\n      response_format:\n        responseFormat?.type === 'json'\n          ? { type: 'json_object', schema: responseFormat.schema }\n          : undefined,\n\n      // messages:\n      messages: chatPrompt,\n    };\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareTools(mode);\n        // TODO(shaper): Cohere API doesn't appear to support any form of\n        // explicit tool choice currently. In the future we may want to pass\n        // along the `tool_choice` value in some manner.\n        return {\n          ...baseArgs,\n          tools,\n          warnings: toolWarnings,\n        };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new UnsupportedFunctionalityError({\n          functionality: `Unsupported mode: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  concatenateMessageText(messages: CohereChatPrompt): string {\n    return messages\n      .filter(\n        (\n          message,\n        ): message is\n          | CohereSystemMessage\n          | CohereUserMessage\n          | CohereAssistantMessage => 'content' in message,\n      )\n      .map(message => message.content)\n      .join('');\n  }\n\n  /*\n  Remove `additionalProperties` and `$schema` from the `parameters` object of each tool.\n  Though these are part of JSON schema, Cohere chokes if we include them in the request.\n  */\n  // TODO(shaper): Look at defining a type to simplify the params here and a couple of other places.\n  removeJsonSchemaExtras(\n    tools: Array<{\n      type: 'function';\n      function: {\n        name: string | undefined;\n        description: string | undefined;\n        parameters: unknown;\n      };\n    }>,\n  ) {\n    return tools.map(tool => {\n      if (\n        tool.type === 'function' &&\n        tool.function.parameters &&\n        typeof tool.function.parameters === 'object'\n      ) {\n        const { additionalProperties, $schema, ...restParameters } = tool\n          .function.parameters as Record<string, unknown>;\n        return {\n          ...tool,\n          function: {\n            ...tool.function,\n            parameters: restParameters,\n          },\n        };\n      }\n      return tool;\n    });\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { warnings, ...args } = this.getArgs(options);\n    args.tools = args.tools && this.removeJsonSchemaExtras(args.tools);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages, ...rawSettings } = args;\n    let text = response.message.content?.[0]?.text ?? '';\n\n    return {\n      text,\n      toolCalls: response.message.tool_calls\n        ? response.message.tool_calls.map(toolCall => ({\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            // Cohere sometimes returns `null` for tool call arguments for tools\n            // defined as having no arguments.\n            args: toolCall.function.arguments.replace(/^null$/, '{}'),\n            toolCallType: 'function',\n          }))\n        : [],\n      finishReason: mapCohereFinishReason(response.finish_reason),\n      usage: {\n        promptTokens: response.usage.tokens.input_tokens,\n        completionTokens: response.usage.tokens.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: {\n          messages,\n        },\n        rawSettings,\n      },\n      response: {\n        id: response.generation_id ?? undefined,\n      },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(args) },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { warnings, ...args } = this.getArgs(options);\n    args.tools = args.tools && this.removeJsonSchemaExtras(args.tools);\n    const body = { ...args, stream: true };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        cohereChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n\n    let pendingToolCallDelta: {\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    } = {\n      toolCallId: '',\n      toolName: '',\n      argsTextDelta: '',\n    };\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof cohereChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n            const type = value.type;\n\n            switch (type) {\n              case 'content-delta': {\n                controller.enqueue({\n                  type: 'text-delta',\n                  textDelta: value.delta.message.content.text,\n                });\n                return;\n              }\n\n              case 'tool-call-start': {\n                // The start message is the only one that specifies the tool id and name.\n                pendingToolCallDelta = {\n                  toolCallId: value.delta.message.tool_calls.id,\n                  toolName: value.delta.message.tool_calls.function.name,\n                  argsTextDelta:\n                    value.delta.message.tool_calls.function.arguments,\n                };\n\n                // Provide visibility into the beginning of the tool call even\n                // though we likely don't have full arguments yet.\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallId: pendingToolCallDelta.toolCallId,\n                  toolName: pendingToolCallDelta.toolName,\n                  toolCallType: 'function',\n                  argsTextDelta: pendingToolCallDelta.argsTextDelta,\n                });\n                return;\n              }\n\n              case 'tool-call-delta': {\n                // Accumulate the arguments for the tool call.\n                pendingToolCallDelta.argsTextDelta +=\n                  value.delta.message.tool_calls.function.arguments;\n\n                // Provide visibility into the updated arguments for the tool call, even though we\n                // may have more arguments still coming.\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallId: pendingToolCallDelta.toolCallId,\n                  toolName: pendingToolCallDelta.toolName,\n                  toolCallType: 'function',\n                  argsTextDelta:\n                    value.delta.message.tool_calls.function.arguments,\n                });\n                return;\n              }\n\n              case 'tool-call-end': {\n                // Post the full tool call now that we have all of the arguments.\n                controller.enqueue({\n                  type: 'tool-call',\n                  toolCallId: pendingToolCallDelta.toolCallId,\n                  toolName: pendingToolCallDelta.toolName,\n                  toolCallType: 'function',\n                  args: JSON.stringify(\n                    JSON.parse(\n                      pendingToolCallDelta.argsTextDelta?.trim() || '{}',\n                    ),\n                  ),\n                });\n\n                // Clear the pending tool call. We rely on the API always\n                // following a start with an end. We do not defensively clear a\n                // previous accumulation of a pending tool call in\n                // non-tool-related events.\n                pendingToolCallDelta = {\n                  toolCallId: '',\n                  toolName: '',\n                  argsTextDelta: '',\n                };\n                return;\n              }\n\n              case 'message-start': {\n                controller.enqueue({\n                  type: 'response-metadata',\n                  id: value.id ?? undefined,\n                });\n\n                return;\n              }\n\n              case 'message-end': {\n                finishReason = mapCohereFinishReason(value.delta.finish_reason);\n                const tokens = value.delta.usage.tokens;\n\n                usage = {\n                  promptTokens: tokens.input_tokens,\n                  completionTokens: tokens.output_tokens,\n                };\n              }\n\n              default: {\n                return;\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: {\n          messages,\n        },\n        rawSettings,\n      },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereChatResponseSchema = z.object({\n  generation_id: z.string().nullish(),\n  message: z.object({\n    role: z.string(),\n    content: z\n      .array(\n        z.object({\n          type: z.string(),\n          text: z.string(),\n        }),\n      )\n      .nullish(),\n    tool_plan: z.string().nullish(),\n    tool_calls: z\n      .array(\n        z.object({\n          id: z.string(),\n          type: z.literal('function'),\n          function: z.object({\n            name: z.string(),\n            arguments: z.string(),\n          }),\n        }),\n      )\n      .nullish(),\n  }),\n  finish_reason: z.string(),\n  usage: z.object({\n    billed_units: z.object({\n      input_tokens: z.number(),\n      output_tokens: z.number(),\n    }),\n    tokens: z.object({\n      input_tokens: z.number(),\n      output_tokens: z.number(),\n    }),\n  }),\n});\n\n// limited version of the schema, focused on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereChatChunkSchema = z.discriminatedUnion('type', [\n  z.object({\n    type: z.literal('citation-start'),\n  }),\n  z.object({\n    type: z.literal('citation-end'),\n  }),\n  z.object({\n    type: z.literal('content-start'),\n  }),\n  z.object({\n    type: z.literal('content-delta'),\n    delta: z.object({\n      message: z.object({\n        content: z.object({\n          text: z.string(),\n        }),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('content-end'),\n  }),\n  z.object({\n    type: z.literal('message-start'),\n    id: z.string().nullish(),\n  }),\n  z.object({\n    type: z.literal('message-end'),\n    delta: z.object({\n      finish_reason: z.string(),\n      usage: z.object({\n        tokens: z.object({\n          input_tokens: z.number(),\n          output_tokens: z.number(),\n        }),\n      }),\n    }),\n  }),\n  // https://docs.cohere.com/v2/docs/streaming#tool-use-stream-events-for-tool-calling\n  z.object({\n    type: z.literal('tool-plan-delta'),\n    delta: z.object({\n      message: z.object({\n        tool_plan: z.string(),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('tool-call-start'),\n    delta: z.object({\n      message: z.object({\n        tool_calls: z.object({\n          id: z.string(),\n          type: z.literal('function'),\n          function: z.object({\n            name: z.string(),\n            arguments: z.string(),\n          }),\n        }),\n      }),\n    }),\n  }),\n  // A single tool call's `arguments` stream in chunks and must be accumulated\n  // in a string and so the full tool object info can only be parsed once we see\n  // `tool-call-end`.\n  z.object({\n    type: z.literal('tool-call-delta'),\n    delta: z.object({\n      message: z.object({\n        tool_calls: z.object({\n          function: z.object({\n            arguments: z.string(),\n          }),\n        }),\n      }),\n    }),\n  }),\n  z.object({\n    type: z.literal('tool-call-end'),\n  }),\n]);\n","import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\nconst cohereErrorDataSchema = z.object({\n  message: z.string(),\n});\n\nexport type CohereErrorData = z.infer<typeof cohereErrorDataSchema>;\n\nexport const cohereFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: cohereErrorDataSchema,\n  errorToMessage: data => data.message,\n});\n","import {\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { CohereAssistantMessage, CohereChatPrompt } from './cohere-chat-prompt';\n\nexport function convertToCohereChatPrompt(\n  prompt: LanguageModelV1Prompt,\n): CohereChatPrompt {\n  const messages: CohereChatPrompt = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'system', content });\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content\n            .map(part => {\n              switch (part.type) {\n                case 'text': {\n                  return part.text;\n                }\n                case 'image': {\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'image-part',\n                  });\n                }\n              }\n            })\n            .join(''),\n        });\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: CohereAssistantMessage['tool_calls'] = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function' as const,\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n            default: {\n              const _exhaustiveCheck: never = part;\n              throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n            }\n          }\n        }\n\n        messages.push({\n          role: 'assistant',\n          // note: this is a workaround for a Cohere API bug\n          // that requires content to be provided\n          // even if there are tool calls\n          content: text !== '' ? text : 'call tool',\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          tool_plan: undefined,\n        });\n\n        break;\n      }\n      case 'tool': {\n        // Cohere uses one tool message per tool result\n        messages.push(\n          ...content.map(toolResult => ({\n            role: 'tool' as const,\n            content: JSON.stringify(toolResult.result),\n            tool_call_id: toolResult.toolCallId,\n          })),\n        );\n\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return messages;\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapCohereFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'COMPLETE':\n    case 'STOP_SEQUENCE':\n      return 'stop';\n\n    case 'MAX_TOKENS':\n      return 'length';\n\n    case 'ERROR':\n    case 'ERROR_LIMIT':\n      return 'error';\n\n    case 'ERROR_TOXIC':\n      return 'content-filter';\n\n    case 'USER_CANCEL':\n      return 'other';\n\n    default:\n      return 'unknown';\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\n// For reference: https://docs.cohere.com/docs/parameter-types-in-tool-use\nexport function prepareTools(\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  },\n): {\n  tools:\n    | Array<{\n        type: 'function';\n        function: {\n          name: string | undefined;\n          description: string | undefined;\n          parameters: unknown;\n        };\n      }>\n    | undefined;\n  tool_choice:\n    | { type: 'function'; function: { name: string } }\n    | 'auto'\n    | 'none'\n    | 'any'\n    | undefined;\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  const tools = mode.tools?.length ? mode.tools : undefined;\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const cohereTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: unknown;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      cohereTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        },\n      });\n    }\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (toolChoice == null) {\n    return { tools: cohereTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return { tools: cohereTools, tool_choice: type, toolWarnings };\n\n    case 'none':\n      // Cohere does not support 'none' tool choice, so we remove the tools.\n      return { tools: undefined, tool_choice: 'any', toolWarnings };\n\n    case 'required':\n    case 'tool':\n      // Cohere does not support forcing tool calls\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${type}`,\n      });\n\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  FetchFunction,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport {\n  CohereEmbeddingModelId,\n  CohereEmbeddingSettings,\n} from './cohere-embedding-settings';\nimport { cohereFailedResponseHandler } from './cohere-error';\n\ntype CohereEmbeddingConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class CohereEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: CohereEmbeddingModelId;\n\n  readonly maxEmbeddingsPerCall = 96;\n  readonly supportsParallelCalls = true;\n\n  private readonly config: CohereEmbeddingConfig;\n  private readonly settings: CohereEmbeddingSettings;\n\n  constructor(\n    modelId: CohereEmbeddingModelId,\n    settings: CohereEmbeddingSettings,\n    config: CohereEmbeddingConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/embed`,\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        // The AI SDK only supports 'float' embeddings which are also the only ones\n        // the Cohere API docs state are supported for all models.\n        // https://docs.cohere.com/v2/reference/embed#request.body.embedding_types\n        embedding_types: ['float'],\n        texts: values,\n        input_type: this.settings.inputType ?? 'search_query',\n        truncate: this.settings.truncate,\n      },\n      failedResponseHandler: cohereFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        cohereTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.embeddings.float,\n      usage: { tokens: response.meta.billed_units.input_tokens },\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst cohereTextEmbeddingResponseSchema = z.object({\n  embeddings: z.object({\n    float: z.array(z.array(z.number())),\n  }),\n  meta: z.object({\n    billed_units: z.object({\n      input_tokens: z.number(),\n    }),\n  }),\n});\n"],"mappings":"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","names":["UnsupportedFunctionalityError","z","UnsupportedFunctionalityError","UnsupportedFunctionalityError","z","combineHeaders","createJsonResponseHandler","postJsonToApi","z","postJsonToApi","combineHeaders","createJsonResponseHandler","z"]}